# V8 的垃圾回收机制 与 内存限制

## 内存限制

  > Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4 GB，32 位系统下约为 0.7 GB）
  > Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的

  - V8 的对象分配

  - V8 中内存使用量的查看方式

    > memoryUsage()

    ```javascript
    process.memoryUsage();
    {
    rss: 25976832,
    heapTotal: 5959680, // 已申请到的堆内存
    heapUsed: 3740328,  // 当前使用的量
    external: 1390755
    }
    ```

    1. 当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。
    2. 如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制为止。

    - V8 为何限制堆的大小
      > 按官方的说法，以 1.5 GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。
      > 垃圾回收导致 JavaScript 线程暂停
      > 在这样的时间花销下，应用的性能和响应能力都会直线下降

## 垃圾回收机制

  > V8 的垃圾回收策略主要基于分代式垃圾回收机制
  > 统计学在垃圾回收算法的发展中产生较大作用，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，对不同分代的内存施以更高效的算法。

  - V8 内存分代

    1. 新生代
       > 新生代中的对象为存活时间较短的对象
       > --max-old-space-size 设置老生代内存空间的最大值
    2. 老生代

       > 对象为存活时间较长或常驻内存的对象
       > --max-new-space-size 设置新生代内存空间的最大值

    > 设置 新生代 或 老生代 内存需要在启动时指定,V8 不能自己自动扩充,当内存分配过程中超过极限值时，就会引起进程出错

  - Scavenge 算法

    > 主要采用了 Cheney 算法,该算法由 C. J. Cheney 于 1970 年首次发表在 ACM 论文上
    > 缺点:只能使用堆内存中的一半，这是由划分空间和复制机制所决定的

    - Cheney 算法

      > 是一种采用复制的方式实现的垃圾回收算法
      > 通过将存活对象在两个 semispace 空间之间进行复制
      > 空间换取时间的算法

      1. 堆内存一分为二,每一部分空间称为 semispace
      2. 在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态
      3. 处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。
      4. 当我们分配对象时，先是在 From 空间中进行分配
      5. 当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。
      6. 完成复制后，From 空间和 To 空间的角色发生对换

    - 场景
      > 只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现
      > 新生代中对象的生命周期较短,恰恰适合这个算法

  - 晋升

    1. 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。
    2. 较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理
    3. 对象从新生代中移动到老生代中的过程

    - 晋升条件

      - 对象是否经历过 Scavenge 回收

        1. 在默认情况下，V8 的对象分配主要集中在 From 空间中
        2. 对象从 From 空间中复制到 To 空间时，会检查它的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收。
        3. 如果已经经历过了，会将该对象从 From 空间复制到老生代空间中
        4. 如果没有，则复制到 To 空间中。

        > semi space(from) -> 经历过 Scavenge 回收 -> 老生代空间
        > semi space(from) -> 没有经历过 Scavenge 回收 -> semi space(to)

      - To 空间的内存占用比超过限制

        > 当要从 From 空间复制一个对象到 To 空间时，如果 To 空间已经使用了超过 25%，则这个对象直接晋升到老生代空间中

        > semi space(from) -> semi space(from)已经使用超过 25% -> 老生代空间
        > semi space(from) -> semi space(from)没有使用超过 25% -> semi space(To)

        - 设置 25%的阀值
          > 当这次 Scavenge 回收完成后，这个 To 空间将变成 From 空间，接下来的内存分配将在这个空间中进行。
          > 如果占比过高，会影响后续的内存分配。

    > 晋升到老生代空间存活周期较长的对象来对待，接受新的回收算法处理

  - Mark-Sweep(标记清除) & Mark-Compact(标记整理)

    - 对于老生代中的对象，由于存活对象占较大比重，再采用 Scavenge 的方式会有两个问题

      1. 存活对象较多，复制存活对象的效率低
      2. 浪费一半空间的问题

    - Mark-Sweep(标记清除)

      1. 标记
      2. 清除

      > Mark-Sweep 并不将内存空间划分为两半，所以不存在浪费一半空间的行为。

      - 流程

        - 标记阶段
          > 遍历堆中的所有对象，并标记活着的对象
        - 清除阶段
          > 只清除没有被标记的对象

      - 进行一次标记清除回收后，内存空间会出现不连续的状态
        > 内存碎片会对后续的内存分配造成问题，当需要分配一个大对象的情况，这时碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的

    - Scavenge 与 Mark-Sweep 回收方式能高效处理的原因

      1. Scavenge 中只复制活着的对象
      2. Mark-Sweep 只清理死亡对象
         > 活对象在新生代中只占较小部分，死对象在老生代中只占较小部分

    - Mark-Compact(标记整理)

      > 解决 Mark-Sweep 的内存碎片问题

      - 流程
        - 标记阶段
          > 遍历堆中的所有对象，并标记活着的对象
        - 整理阶段
          > 活着的对象往一端移动，移动完成后，直接清理掉边界外的内存

  - 性能对比

    1. Mark-Sweep(标记清理) 速度中等 空间开销少(有碎片) 不移动对象
    2. Mark-Compact(标记整理) 速度最慢 空间开销少(无碎片) 移动对象
    3. Scavenge 速度最快 双倍空间(无碎片) 移动对象

  - V8 垃圾回收策略优先级:

    1. V8 主要使用 Mark-Sweep
    2. 在空间不足时,从新生代中晋升过来的对象进行分配时才使用 Mark-Compact

  - Incremental Marking(增量标记)

    - 全停顿
      > 避免 JavaScript 与 垃圾回收器 数据不一致的情况,上面三种都需要将逻辑应用暂停,完全执行回收器后在恢复应用逻辑
    - 影响

      1. 新生代
         > 由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大
      2. 老生代
         > 配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的过多停顿

    - 避免垃圾回收带来的停顿时间

      1. V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking）
      2. 拆分为许多小“步进”，每做完一“步进”就让 JavaScript 应用逻辑执行一小会儿，
      3. 垃圾回收与应用逻辑交替执行直到标记阶段完成

      > javascript:|->|-----------------------------|->|--|->|--|---------------|->|
      > 垃圾回收:----|--|--初始化标记(停顿)--->(增量标记)|--|->|--|->|---清理/整理---->|--|

      - 最大停顿时间减少原本的 1/6 左右

    - 延迟清理（lazy sweeping）
    - 增量式整理（incremental compaction）
    - 并行标记
    - 并行清理

    > 进一步减少停顿时间

## JavaScript 中无法立即回收的内存

  1. 闭包
  2. 全局变量引用

  > 心此类变量是否无限制地增加，因为它会导致老生代中的对象增多

## 内存泄漏
  - 造成内存泄漏的原因
    1. 缓存
       1. 一个对象被当做缓存来使用,那就意味着它将会常驻在老生代中
       2. 用对象的键值对来缓存东西,这与严格意义上的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有
          > 在 Node 中，任何试图拿内存当缓存的行为都应当被限制。
       - 解决方案:
       1. 缓存限制策略(限定缓存对象的大小)
       2. 采用进程外的缓存，进程自身不存储状态
          - 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效
          - 进程之间可以共享缓存
    2. 队列消费不及时
    3. 作用域未释放
