/*
 * @File Name: greedy.js
 * @Description: 贪心算法
 * @Author: oDen7
 * @LastEditors: oDen7
 * @LastEditTime: 2021-04-30 16:37:21
 */

import {
    createH1_Element,
    createP_Element
} from "./tools"

/*
    贪婪算法

    1.教室调度问题

        假设有如下课程表，你希望将尽可能多的课程安排在某间教室上。
        课程      开始时间       结束时间
        美术      9:00AM        10:00AM  
        英语      9:30AM        10:30AM  X
        数学      10:00AM       11:00AM
        计算机    10:30AM       11:30AM  X
        音乐      11:00AM       12:00PM

        你没法让这些课都在这间教室上，因为有些课的上课时间有冲突。

        你希望在这间教室上尽可能多的课。如何选出尽可能多且时间不冲突的课程呢？
        这个问题好像很难，不是吗？实际上，算法可能简单得让你大吃一惊。具体做法如下。
            (1) 选出结束最早的课，它就是要在这间教室上的第一堂课。
            (2) 接下来，必须选择第一堂课结束后才开始的课。
                同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。
            重复这样做就能找出答案！
        
        下面来试一试。美术课的结束时间最早，为10:00 a.m.，因此它就是第一堂课。
        接下来的课必须在10:00 a.m.后开始，且结束得最早。
        英语课不行，因为它的时间与美术课冲突，但数学课满足条件。
        最后，计算机课与数学课的时间是冲突的，但音乐课可以。

        因此将在这间教室上如下三堂课。
            美术、数学、音乐
    
        贪婪算法的优点——简单易行！
        贪婪算法很简单：每步都采取最优的做法。
        在这个示例中，你每次都选择结束最早的课。
        用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。
        信不信由你，对于这个调度问题，上述简单算法找到的就是最优解！


    2.背包问题

        假设你是个贪婪的小偷，背着可装35磅（1磅≈0.45千克）重东西的背包，在商场伺机盗窃各种可装入背包的商品。
        你力图往背包中装入价值最高的商品，你会使用哪种算法呢？
        同样，你采取贪婪策略，这非常简单。
            (1) 盗窃可装入背包的最贵商品。
            (2) 再盗窃还可装入背包的最贵商品，以此类推。
        只是这次这种贪婪策略不好使了！例如，你可盗窃的商品有下面三种。

        音响  3000美元  30磅
        笔记本电脑  2000美元  20磅
        吉他  1500美元  15磅

        你的背包可装35磅的东西。音响最贵，你把它给偷了，但背包没有空间装其他东西了。
        你偷到了价值3000美元的东西。

        且慢！如果不是偷音响，而是偷笔记本电脑和吉他，总价将为3500美元！

        在这里，贪婪策略显然不能获得最优解，但非常接近。

        在有些情况下，完美是优秀的敌人。
        有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，
            因为它们实现起来很容易，得到的结果又与正确结果相当接近。

        
    3.集合覆盖问题

        假设你办了个广播节目，要让全美50个州的听众都收听得到。
        为此，你需要决定在哪些广播台播出。
        在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。现有广播台名单如下。

        广播台     覆盖的州
        kone      id,nv,ut
        ktwo      wa,id,mt
        kthree    or,nv,ca
        kfour     nv,ut
        kfive     ca,az

        每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。
        如何找出覆盖全美50个州的最小广播台集合呢？听起来很容易，但其实非常难。

        (1) 列出每个可能的广播台集合，这被称为幂集（power set）。可能的子集有2的n次方个。
        (2) 在这些集合中，选出覆盖全美50个州的最小集合。

            问题是计算每个可能的广播台子集需要很长时间。由于可能的集合有2的n次方个，
            因此运行时间为O(2的n次方)。
            如果广播台不多，只有5～10个，这是可行的。
            但如果广播台很多，结果将如何呢？随着广播台的增多，需要的时间将激增。
            假设你每秒可计算10个子集，所需的时间将如下。
            
            广播台数量   需要的时间
            5          3.2秒
            10         102.4秒
            32         13.6年
            100        4*10的21次方年

            
    近似算法
    
        贪婪算法可化解危机！使用下面的贪婪算法可得到非常接近的解。
            (1) 选出这样一个广播台，即它覆盖了最多的未覆盖州。即便这个广播台覆盖了一些已覆盖的州，也没有关系。
            (2) 重复第一步，直到覆盖了所有的州。

        这是一种近似算法（approximation algorithm）。
        在获得精确解需要的时间太长时，可使用近似算法。
        判断近似算法优劣的标准如下：
            (1) 速度有多快；
            (2) 得到的近似解与最优解的接近程度。
        
        贪婪算法是不错的选择，它们不仅简单，而且通常运行速度很快。
        在这个例子中，贪婪算法的运行时间为O(n的2次方)，其中n为广播台数量。

    注:1.并集意味着将集合合并。
       2.交集意味着找出两个集合中都有的元素。
       3.差集意味着将从一个集合中剔除出现在另一个集合中的元素。
            
       集合类似于列表，只是不能包含重复的元素；
       你可执行一些有趣的集合运算，如并集、交集和差集。


    NP完全问题
    
        为解决集合覆盖问题，你必须计算每个可能的集合。
        这可能让你想起了第1章介绍的旅行商问题。在这个问题中，旅行商需要前往5个不同的城市。
        他需要找出前往这5个城市的最短路径，为此，必须计算每条可能的路径。
        前往5个城市时，可能的路径有多少条呢？

        旅行商问题
        
            我们从城市数较少的情况着手。假设只涉及两个城市，因此可供选择的路线有两条。

            你可能心存疑惑：在旅行商问题中，必须从特定的城市出发吗？例如，假设我是旅行商。
            我居住在旧金山，需要前往其他4个城市，因此我将从旧金山出发。
            但有时候，不确定要从哪个城市出发。假设联邦快递将包裹从芝加哥发往湾区，包裹将通过
            航运发送到联邦快递在湾区的50个集散点之一，再装上经过不同配送点的卡车。
            该通过航运发送到哪个集散点呢？
            在这个例子中，起点就是未知的。因此，你需要通过计算为旅行商找出起点和最佳路线。

            在这两种情况下，运行时间是相同的。
            但出发城市未定时更容易处理，因此这里以这种情况为例。涉及两个城市时，可能的路线有两条。

            3个城市
            现在假设再增加一个城市，可能的路线有多少条呢？
            如果从伯克利出发，就需前往另外两个城市。

            从每个城市出发时，都有两条不同的路线，因此总共有6条路线。
            因此涉及3个城市时，可能的路线有6条。

            4个城市
            我们再增加一个城市——弗里蒙特。现在假设从弗里蒙特出发。
            从弗里蒙特出发时，有6条可能的路线。这些路线与前面只有3个城市时计算的6条路线很像，
            只是现在所有的路线都多了一个城市——弗里蒙特！这里有一个规律。
            假设有4个城市，你选择一个出发城市——弗里蒙特后，还余下3个城市。
            而你知道，涉及3个城市时，可能的路线有6条。
            从弗里蒙特出发时，有6条可能的路线，但还可以从其他任何一个城市出发。

            可能的出发城市有4个，从每个城市出发时都有6条可能的路线，因此可能的路线有4 × 6 = 24条。
            你看出规律了吗？每增加一个城市，需要计算的路线数都将增加。

            涉及6个城市时，可能的路线有多少条呢？如果你说720条，那就对了。
            7个城市为5040条，8个城市为40 320条。
            这被称为阶乘函数（factorial function），第3章介绍过。
            5! = 120。假设有10个城市，可能的路线有多少条呢？
            10! = 3 628 800。
            换句话说，涉及10个城市时，需要计算的可能路线超过300万条。
            正如你看到的，可能的路线数增加得非常快！
            因此，如果涉及的城市很多，根本就无法找出旅行商问题的正确解。
            旅行商问题和集合覆盖问题有一些共同之处：
                你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。

        近似求解 
            对旅行商问题来说，什么样的近似算法不错呢？能找到较短路径的算法就算不错。
            在继续往下阅读前，看看你能设计出这样的算法吗？
            我会采取这样的做法：随便选择出发城市，然后每次选择要去的下一个城市时，都选择还
            没去的最近的城市。假设旅行商从马林出发。

            马林 -> 10英里 -> 旧金山
            旧金山 -> 14英里 -> 伯克利
            伯克利 -> 31英里 -> 弗里费特
            弗里费特 -> 16公里 -> 帕洛阿尔托

            总旅程为71英里。这条路径可能不是最短的，但也相当短了。

    NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。
    很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。

    
    如何识别NP完全问题
        Jonah正为其虚构的橄榄球队挑选队员。
        他列了一个清单，指出了对球队的要求：优秀的四分卫，优秀的跑卫，擅长雨中作战，以及能承受压力等。
        他有一个候选球员名单，其中每个球员都满足某些要求。

        Jonah需要组建一个满足所有这些要求的球队，可名额有限。等等，Jonah突然间意识到，这
        不就是一个集合覆盖问题吗！

        Jonah可使用前面介绍的近似算法来组建球队。
            (1) 找出符合最多要求的球员。
            (2) 不断重复这个过程，直到球队满足要求（或球队名额已满）。
        NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用
        去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于
        解决的问题和NP完全问题的差别通常很小。例如，前一章深入讨论了最短路径，你知道如何找
        出从A点到B点的最短路径。

        
        注:但如果要找出经由指定几个点的的最短路径，就是旅行商问题——NP完全问题。
           简言之，没办法判断问题是不是NP完全问题，但还是有一些蛛丝马迹可循的。
            1.元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
            2.涉及“所有组合”的问题通常是NP完全问题。
            3.不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
            4.如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。
            5.如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。
            6.如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

*/

// 可供选择的广播台清单
// 其中的键为广播台的名称，值为广播台覆盖的州。
const stations = {};
stations["kone"] = new Set(["id", "nv", "ut"]);
stations["ktwo"] = new Set(["wa", "id", "mt"]);
stations["kthree"] = new Set(["or", "nv", "ca"]);
stations["kfour"] = new Set(["nv", "ut"]);
stations["kfive"] = new Set(["ca", "az"]);

const greedyFun = () => {
    //包含要覆盖的州
    let states_needed = new Set(["mt", "wa", "or", "id", "nv", "ut", "ca", "az"]);
    let final_stations = new Set();
    while (states_needed.size !== 0) { // states_needed为空
        let best_station = null; // 覆盖了最多的未覆盖州的广播台
        let states_covered = new Set(); // 广播台覆盖的所有未覆盖的州

        for (let key in stations) {
            // 取交集
            // 含同时出现在states_needed和states_for_station中的州
            // 换言之，它包含当前广播台覆盖的一系列还未覆盖的州！
            let covered = new Set([...states_needed].filter(x => stations[key].has(x)));
            if (covered.size > states_covered.size) { // 检查该广播台覆盖的州是否比best_station多
                best_station = key; // 设置为当前广播台
                states_covered = covered;
            }
        }
        // 取差集
        // 由于该广播台覆盖了一些州，因此不用再覆盖这些州
        states_needed = new Set([...states_needed].filter(x => !states_covered.has(x)));
        final_stations.add(best_station)
    }
    return final_stations;
}

export const greedy = () => {
    const greedy = document.createElement("greedy");
    greedy.appendChild(createH1_Element(`贪心算法`));
    console.time("greedy");
    let str = "";
    greedyFun().forEach(item => {
        str += `${item},`
    })
    greedy.appendChild(createP_Element(`${str}`));
    console.timeEnd("greedy");
    return greedy;
}


/*
    // set的创建
    var set1 = new Set([1,2,3]);
    var set2 = new Set([2,3,4]);
    
    // set的属性
    size:表示集合中的元素个数

    // set的元素增加
    set1.add(value)

    // set的删除
    set.clear() // 清空一个set对象的所有元素
    set.delete(value)  // 可以从set对象中删除指定的元素.
                          value是要删除的值
                          成功返回true,否则false
    
    // set的查找和遍历
    set.forEach()和数组的forEach()一致
    set.entries() 返回一个新的迭代器对象,这个对象的元素是类似[value,value]形式的数组
    set.values() 返回一个新生成的可迭代对象,以插入Set对象的顺序返回其包含的每个元素的值

    注:由于Set的key和value是完全一样的，所以set.keys()效果和set.values()是完全一致的。
       同时可以对比 set.entries()和这两方法的区别。

    set.has(value) 参数value用以测试该值是否存在于Set对象中，如果存在则返回true, 否则返回false


    并集
    let union = new Set([...set1, ...set2]);
    交集
    let intersect = new Set([...set1].filter( x => set2.has(x)));
    差集
    let difference = new Set([...set1].filter(x => !set2.has(x)));
*/