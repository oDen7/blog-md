# 概述

### 原始值,引用值
- 原始值
    1. 6种原始值,按值引用
    2. 没有属性,可通过new关键字,创建object实例
    3. 复制时,会重新分配内存
    4. 传参时,按值传递
    5. 使用 typeof 判断, instanceof 对于原始值始终返回 false
- 引用值
    1. 由多个值构成的对象,按引用访问
    2. 复制时,创建新指针指向同一块儿内存空间
    3. 传参时,按引用传递
    4. instanceof 判断 任何引用值 或 Object 构造函数返回 true,typeof 判断对象或null 返回 "object"



### 执行上下文与作用域
1. 全局上下文 -- window对象
2. 局部(函数)上下文
    - 当代码执行流进入函数时，函数的上下文被推到上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。
3. 作用域链
    - 决定各级上下文访问变量和函数的顺序
4. 活动对象 arguments(全局上下文没有)
    - 作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；
    - 全局上下文的变量对象始终是作用域链的最后一个变量对象。
5. 作用域链增强
    - try/catch 的 catch
    - with // 执行效率低

6. 标识符查找
    - 在局部上下文找到后并返回,否则接着沿作用域链查找,直到全文上下文

### 垃圾回收
1. 标记引用 (目前的解决方案)
    - 上下文中变量在代码运行时添加标记,执行结束后添加删除标记。
    - 垃圾回收程序:标记所有变量,去掉上下文中被引用的变量标记,此时被添加标记的变量就是待删除的(没有上下文能访问到),最后进行内存清理,回收带标记的的所有值内存
2. 引用计数
    - 对每个值进行引用记录.变量(引用值为1)赋于另一个变量时,前者引用值加1.变量被覆盖时,引用值减1. 垃圾回收会回收标记为0的值内存。
    - 引用循环: 对象A指针指向对象B,对象B指针指向对象A,导致引用数都为2.(引用数默认为1),所以永远不会被回收
    - 在不切断原生JavaScript对象与DOM元素之间的连接时,使用 null 解除循环,称为 解除引用

### 内存管理
1. 通过 const 和 let 有助于提升性能
    - 有助于尽早使用 垃圾回收程序 介入
2. 隐藏类和删除操作
- 运行期间,v8创建的对象与隐藏类相关联,以跟踪它们的特征.能共享相同隐藏类的对象性能更好
- 先创建再补充(ready-fire-aim)式的动态属性赋值,并一次性声明所有属性
```javascript 
function Article(opt_author) {
    this.title = 'Inauguration Ceremony Features Kazoo Band'; 
    this.author = opt_author; 
} 
let a1 = new Article(); 
let a2 = new Article('Jake'); 
```
- 将不使用的值设为 null,可以保持隐藏类不变和继续共享,也能达到删除引用值供垃圾回回收程序回收

### 内存泄漏
1. 初始化不声明变量会导致一直将值挂在到window上无法回收
2. 定时器导致内存泄漏
```javascript
let name = 'Jake';
setInterval(() => { 
    console.log(name); 
}, 100);
// 只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。

let outer = function() {
    let name = 'Jake'; 
    return function() { 
        return name; 
    }; 
};
// 调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。
```

3. 静态分配与对象池
- 浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。
```javascript
function addVector(a, b) {
    let resultant = new Vector(); 
    resultant.x = a.x + b.x; 
    resultant.y = a.y + b.y; 
    return resultant; 
} 
//该问题的解决方案是不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象

function addVector(a, b, resultant) {
    resultant.x = a.x + b.x; 
    resultant.y = a.y + b.y; 
    return resultant; 
} 
```
    
- 对象池
    1. 提前创建一组可管理并可回收的对象
    2. 请求一个对象,设置其属性、使用它
    3. 操作完成后再把它还给对象池